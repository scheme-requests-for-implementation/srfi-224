<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>SRFI 224: Integer Mappings</title>
  <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
  <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>pre.example { margin-left: 2em; }</style>
</head>
<body>
  <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI surfboard logo" /></a>224: Integer Mappings</h1>

<p>by Wolfgang Corcoran-Mathe</p>

<h2 id="status">Status</h2>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+224+at+srfi+dotschemers+dot+org">srfi-224@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="https://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-224">archive</a>.</p>
<ul>
  <li>Received: 2021-03-24</li>
  <li>60-day deadline: 2021-05-23</li>
  <li>Draft #1 published: 2021-03-24</li>
  <li>Wolfgang's <a href="https://github.com/Zipheir/imappings-pre-srfi">personal
       Git repo for this SRFI</a> for reference while the SRFI is in
       <em>draft</em> status<!-- (<a href="https://htmlpreview.github.io/?https://github.com/Zipheir/imappings-pre-srfi/blob/main/srfi-224.html">preview</a>) --></li>
</ul>

<h2>Abstract</h2>

<p>Integer maps, or <em>imappings</em>, are finite sets, where each element is
an association between an exact-integer key and an arbitrary Scheme
object.  They are similar to the general mappings of
<a href="https://srfi.schemers.org/srfi-146/">SRFI
146</a>, but the restricted key-type allows implementations of
imappings to benefit from optimized structures and algorithms.  This
library provides a rich set of operations on imappings, including
analogues of most of the forms provided by SRFI 146.  Imappings have
no intrinsic order, but may be treated as ordered sets, using the
natural ordering on keys; a substantial sublibrary for working with
imappings in this fashion is included.</p>

<h2>Issues</h2>

<p>Maybe and Either are somewhat controversial in the Scheme community;
should procedures using them be moved to an optional sublibrary?</p>

<h2>Rationale</h2>

<p>&ldquo;Finite maps are the workhorse data structure in every compiler.&rdquo;
&ndash;Okasaki &amp; Gill</p>

<p>Mappings provide operations that are critical to a host of functional
algorithms. They describe finite sets of key-value associations (pairs)
which can be efficiently extended, queried, and transformed.  Critically,
all of these operations can be efficiently implemented as &ldquo;pure&rdquo;
functions.  While
hash-tables (see <a href="https://srfi.schemers.org/srfi-125/">SRFI 125</a>)
provide similar operations, they generally provide a strictly imperative
language for insertion of associations and mutation of association
sets.</p>

<p>Mappings are already familiar to Scheme;
<a href="https://srfi.schemers.org/srfi-146/">SRFI 146</a> provides general
mappings and was added to the Tangerine Edition of R7RS-large.  But
the generality of SRFI 146 is costly.  Any comparable type of Scheme
object can be used as a key in a SRFI 146 mapping, so comparisons
between keys must use the dispatch-based generic methods of
<a href="https://srfi.schemers.org/srfi-128/">SRFI 128</a>.  This is overkill for
many use-cases; in particular, if we wish to use exact integers as keys,
we expect comparisons to be very efficient and to require no mediation
from a comparison dictionary.  In addition,
some efficient and simple mapping representations, for example the
Okasaki-Gill radix tree model used in this SRFI&rsquo;s sample implementation,
are unsuitable for representing general mappings.</p>

<p>The integer mappings we describe restrict the type of keys to
exact integers (&ldquo;fixnums&rdquo;).  This is a ubiquitous type in computing,
and broadly useful as a key-type for mappings; its use opens up a
range of implementation options.</p>

<p>This library provides an interface similar to that used by
SRFI 146, although it diverges in some areas.  In addition,
<code>imapping-adjust</code>, <code>imapping-alter</code>, and
several other forms derive from Haskell&rsquo;s
<a href="https://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html">IntMap</a>
library.</p>

<p>Many forms make
instrumental use of <a href="https://srfi.schemers.org/srfi-189/">SRFI 189&rsquo;s</a>
Maybe type; I believe that this choice results in simpler,
more compositional definitions.  (Compare, for instance, the
<code>mapping-ref</code> form of SRFI 146 with <code>imapping-lookup</code>.)  Where the
use of Maybe values would clarify nothing, I have preferred the
traditional &ldquo;value or <code>#f</code>&rdquo; Lisp protocol.</p>

<p>Unusual among SRFIs, this library provides &ldquo;with-key&rdquo; variants for
many staple higher-order procedures (e.g. <code>map</code>, <code>fold</code>, etc.).
These variants, indicated by the suffix <code>-/key</code>, call their auxiliary
functions on both the keys and values of an imapping (possibly along
with other parameters).  A smaller
library proposal might eschew variant forms of a procedure; consider,
for example, the single index-and-value form of <code>vector-map</code> from
<a href="https://srfi.schemers.org/srfi-133/">SRFI 133</a>.  However, this creates
unnecessary inflexibility and incompatibility between SRFI.  In practice,
the added complexity of providing variant higher-order forms is minimal,
and their availability can be a boon to both the programmer and to the
standardizer.</p>

<p>The specification of this SRFI depends on the Maybe and Either types
specified in SRFI 189 and on the comparator type (used to determine the
equality of values, not keys) described in
SRFI 128.  A few forms also make use of
<a href="https://srfi.schemers.org/srfi-217/">SRFI 217</a> integer sets.
The sample implementation has further dependencies; see the
<a href="#implementation">appropriate section</a> for more details.</p>

<h2>Specification</h2>

<p>Imappings form a new type, as if created by <code>define-record-type</code>
(see R7RS § 5.5). The effects of using record-type inspection or inheritance
for the imapping type are unspecified.</p>

<p>It is an error to add or remove an association of an imapping while
iterating over it.</p>

<h3>Notation</h3>

<p>The words &ldquo;must&rdquo;, &ldquo;may&rdquo;, etc., though not
capitalized in this SRFI, are to be interpreted as described in
<a href="https://tools.ietf.org/html/rfc2119">RFC 2119</a>.</p>

<p>The naming conventions of this document are consistent with those used
in the R7RS Scheme standard.</p>

<p>The following names are used for the parameters of procedures:</p>

<table>
<tr><td><em>obj</em></td><td>Any Scheme object.</td></tr>
<tr><td><em>boolean</em></td><td>A boolean.</td></tr>
<tr><td><em>imap</em></td><td>An integer map (imapping).</td></tr>
<tr><td><em>k</em></td><td>An exact integer.</td></tr>
<tr><td><em>list</em></td><td>A proper list.</td></tr>
<tr><td><em>alist</em></td><td>An association list.</td></tr>
<tr><td><em>proc</em></td><td>A procedure.</td></tr>
<tr><td><em>mproc</em></td><td>A procedure returning a Maybe object.</td></tr>
<tr><td><em>pred</em></td><td>A predicate.</td></tr>
<tr><td><em>comp</em></td><td>A SRFI 128 comparator object.</td></tr>
</table>


<p>It is an error (unless otherwise noted) if the procedures are passed arguments
that do not have the type implied by the argument names.</p>

<p>The pair notation (<em>k</em>,<em>v</em>) is often used to describe
an association of an imapping.  Here, <em>k</em> is the key and
<em>v</em> its associated value.  If an imapping <em>imap</em> is said
to "contain the association (<em>k</em>,<em>v</em>)", then this is to
be understood in the sense that looking up <em>k</em> in <em>imap</em>
(via <code>(imapping-ref</code> <em>imap k</em><code>)</code>, for
example) will produce the value <em>v</em>.</p>

<p>Each procedure is written in the form</p>

<p><code>(</code><em>proc&nbsp;arg₁ arg₂</em> …<code>)</code> → [<em>type</em>₁, <em>type</em>₂, …]</p>

<p>where <em>proc</em> is the name of the procedure, the <em>args</em> are its
parameters, and the <em>types</em> are the types of the objects it returns.
If the procedure returns a single value, the brackets on the right-hand side
may be omitted.
The <em>types</em> refer (informally) to Scheme types; e.g. <code>boolean</code>
denotes a Scheme boolean, <code>list[integer]</code> denotes a list of integers,
etc.  The special notation &lsquo;*&rsquo; indicates that the type
of the value may be anything, depending on the context of the procedure call.
For example, Scheme&rsquo;s <code>list-ref</code> procedure would be written</p>

<p><code>(</code>list-ref <em>list k</em><code>) → *</code></p>

<p>since the type of the return value depends on <em>list</em>.  Multiple
<code>*</code> values appearing in the same type signature do not necessarily
denote the same type.  For example, the signature <code>* * → boolean</code> might
denote the type of a procedure taking two values of the same type to a boolean,
or two values of differing types.  The accompanying description may clarify
the semantics of procedures defined on <code>*</code> values, but Scheme's
type system makes it difficult to explain all of the possible interactions of
these procedures.</p>

<p>A procedure which returns a value of type <em>τ</em><code>-or-false</code>
(where <em>τ</em> denotes a type) returns a <em>τ</em> on success, and
<code>#f</code> otherwise.  Thus the <code>memv</code> procedure of R7RS
would have the type signature <code>* list[*] → list[*]-or-false</code>.</p>

<h3>Linear update</h3>

<p>The procedures of this SRFI, by default, are "pure functional" — they
do not alter their parameters.  However, this SRFI also defines
"linear-update" procedures, all of whose names end in <code>!</code>.
They have hybrid pure/side-effecting semantics: they are allowed,
but not required, to side-effect one of their parameters in
order to construct their result.  An implementation may legally
implement these procedures as pure, side-effect-free functions, or it
may implement them using side effects, depending upon the details of
what is the most efficient or simple to implement in terms of the
underlying representation.</p>

<p>It is an error to rely upon these procedures working by side
effect.  For example, this is not guaranteed to work:</p>

<pre class="example">(let* ((imap1 (imapping 1 'b 2 'c))
       (imap2 (imapping-adjoin! imap1 3 'd)))
  imap1) ; Could be either {(1, b), (2, c)} or {(1, b), (2, c) (3, d)}.
</pre>

<p>However, this is well-defined:</p>

<pre class="example">(let ((imap1 (imapping 1 'b 2 'c)))
  (imapping-adjoin! imap1 3 'd))
</pre>

<p>So clients of these procedures write in a functional style, but
must additionally be sure that, when the procedure is called, there
are no other live references to the potentially-modified imapping
(hence the term "linear update").</p>

<p>There are two benefits to this convention:</p>

<ul><li><p>Implementations are free to provide the most efficient
possible implementation, either functional or side-effecting.</p></li>

<li><p>Programmers may nonetheless continue to assume that imappings are
purely functional data structures: they may be reliably shared without
needing to be copied, uniquified, and so forth.</p></li></ul>

<p>In practice, these procedures are most useful for efficiently
constructing imappings in a side-effecting manner, in some limited local
context, before passing the imapping outside the local construction scope
to be used in a functional manner.</p>

<p>Scheme provides no assistance in checking the linearity of the
potentially side-effected parameters passed to these functions — there's
no linear type checker or run-time mechanism for detecting
violations.</p>

<p>Note that if an implementation uses no side effects at all, it is
allowed to return existing imappings rather than newly allocated ones,
even where this SRFI explicitly says otherwise.</p>

<h3>Index</h3>

<ul>
<li><p><a href="#constructors">Constructors</a>: <code>imapping, imapping-unfold, imapping-unfold-maybe, alist-&gt;imapping,
iset-&gt;imapping</code></p></li>
<li><p><a href="#predicates">Predicates</a>: <code>imapping?, imapping-contains?, imapping-empty?, imapping-disjoint?</code></p></li>
<li><p><a href="#accessors">Accessors</a>: <code>imapping-lookup, imapping-ref, imapping-ref/default, imapping-min, imapping-max</code></p></li>
<li><p><a href="#updaters">Updaters</a>: <code>imapping-adjoin, imapping-adjoin/combinator,
imapping-adjoin!, imapping-adjoin/combinator!, imapping-adjust, imapping-adjust/key,
imapping-adjust!, imapping-adjust/key!,
imapping-delete, imapping-delete!,
imapping-delete-all, imapping-delete-all!, imapping-alter, imapping-alter!, imapping-update,
imapping-update/key, imapping-update!, imapping-update/key!,
imapping-delete-min, imapping-delete-max, imapping-delete-min!, imapping-delete-max!,
imapping-update-min, imapping-update-max, imapping-update-min/key, imapping-update-max/key,
imapping-update-min!, imapping-update-max!, imapping-update-min/key!, imapping-update-max/key!,
imapping-pop-min, imapping-pop-max,
imapping-pop-min!, imapping-pop-max!</code></p></li>
<li><p><a href="#whole">The whole imapping</a>: <code>imapping-size,
imapping-count, imapping-count/key, imapping-any?, imapping-every?</code></p></li>
<li><p><a href="#traversal">Traversal</a>: <code>imapping-fold,
imapping-fold-right, imapping-fold/key, imapping-fold-right/key, imapping-map,
imapping-map/key, imapping-map!, imapping-map/key!,
imapping-map-&gt;list, imapping-map/key-&gt;list, imapping-for-each,
imapping-for-each/key, imapping-filter-map, imapping-filter-map/key,
imapping-filter-map!, imapping-filter-map/key!,
imapping-map-either, imapping-map-either/key,
imapping-map-either!, imapping-map-either/key!,
imapping-relation-map</code></p></li>
<li><p><a href="#filter">Filter</a>: <code>imapping-filter, imapping-filter/key,
imapping-filter!, imapping-filter/key!,
imapping-remove, imapping-remove/key,
imapping-remove!, imapping-remove/key!,
imapping-partition, imapping-partition/key,
imapping-partition!, imapping-partition/key!</code></p></li>
<li><p><a href="#conversion">Copying and conversion</a>: <code>imapping-copy, imapping-&gt;alist,
imapping-&gt;decreasing-alist, imapping-keys,
imapping-values, imapping-keys-set</code></p></li>
<li><p><a href="#comparison">Comparison</a>: <code>imapping=?, imapping&lt;?, imapping&gt;?, imapping&lt;=?, imapping&gt;=?</code></p></li>
<li><p><a href="#settheory">Set theory operations</a>: <code>imapping-union, imapping-intersection, imapping-difference,
imapping-xor,
imapping-union!, imapping-intersection!, imapping-difference!, imapping-xor!,
imapping-union/combinator, imapping-intersection/combinator,
imapping-union/combinator!, imapping-intersection/combinator!</code></p></li>
<li><p><a href="#submappings">Submappings</a>: <code>imapping-open-interval, imapping-closed-interval,
imapping-open-closed-interval, imapping-closed-open-interval,
imapping-open-interval!, imapping-closed-interval!,
imapping-open-closed-interval!, imapping-closed-open-interval!,
isubmapping=, isubmapping&lt;, isubmapping&lt;=, isubmapping&gt;=,
isubmapping&gt;,
isubmapping=!, isubmapping&lt;!, isubmapping&lt;=!, isubmapping&gt;=!,
isubmapping&gt;!</code></p></li>
</ul>

<h3 id="constructors">Constructors</h3>

<p><code>(imapping</code>&nbsp;<em>k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p>Returns a new imapping.  The arguments alternate between keys (which
must be exact integers) and values (which are arbitrary Scheme objects); the
resulting imapping contains these (<em>k</em>, <em>obj</em>) associations.
The number of arguments must be even.  If duplicate keys occur in
the arguments, earlier associations take priority.</p>

<p>Examples:</p>
<pre class="example"><code>(imapping-&gt;alist (imapping 0 'a 1 'b 2 'c)) ⇒ ((0 . a) (1 . b) (2 . c))
(imapping-&gt;alist (imapping -10 "worf" -10 "yar")) ⇒ ((-10 . "worf"))
</code></pre>

<p><code>(imapping-unfold</code>&nbsp;<em>stop? mapper successor seed</em><code>) → imapping</code></p>

The arguments have the following types:
<ul>
<li><em>stop?</em> : <code>* → boolean</code></li>
<li><em>mapper</em> : <code>* → exact-integer *</code></li>
<li><em>successor</em> : <code>* → *</code></li>
<li><em>seed</em> : <code>*</code></li>
</ul>

<p>Unfold a new imapping from the initial seed value <em>seed</em>.
<em>mapper</em> is applied to each seed and returns two values, a key
and an associated value, which are adjoined to the new imapping.
<em>successor</em> maps each seed to a new seed.
Unfolding terminates when the predicate <em>stop?</em> returns a true
value when applied to the current seed.</p>

<p>Example:</p>
<pre class="example"><code>(imapping-&gt;alist
 (imapping-unfold (lambda (i) (= i 4))
                  (lambda (i) (values i (make-string i #\a)))
                  (lambda (i) (+ i 1))
                  0))
 ⇒ ((0 . "") (1 . "a") (2 . "aa") (3 . "aaa"))
</code></pre>

<p><code>(imapping-unfold-maybe</code>&nbsp;<em>mproc seed</em><code>) → imapping</code></p>

The arguments have the following types:
<ul>
<li><em>mproc</em> : <code>* → maybe[exact-integer, *, *]</code></li>
<li><em>seed</em> : <code>*</code></li>
</ul>

<p>Unfold a new imapping.  <em>mproc</em> is applied to <em>seed</em> and returns
a Maybe value.  If this value is Nothing, then unfolding terminates.
If it is Just <em>k v seed′</em>, then a new association
<em>(k, v)</em> is added to the resulting imapping and unfolding continues
with <em>seed′</em>.</p>

<p>Example:</p>
<pre class="example"><code>(imapping-&gt;alist
 (imapping-unfold-maybe (lambda (i)
                          (if (&lt; i -3)
                              (nothing)
                              (just i (square i) (- i 1))))
                        -1))
 ⇒ ((-3 . 9) (-2 . 4) (-1 . 1))
</code></pre>

<strong>Rationale:</strong> As well as sometimes leading to more compact
expressions than the
traditional "three procedure" unfold, <code>imapping-unfold-maybe</code>
is also more efficient when the programmer wants the value of each new seed
to depend on the computed key and value.  For example,
assume that we apply some procedure <em>f</em> to a seed <em>s</em> to get a
key <em>k</em> and a value <em>v</em>, and that we also want to compute a new
seed from <em>k</em> and <em>v</em>.  Using <em>imapping-unfold</em>, we'd
have no choice other than to compute <em>k</em> and <em>v</em> twice:

<pre class="example"><code>(imapping-unfold stop?
                 f
                 (lambda (s)
                   (let-values (((k v) (f s)))
                     (let ((s* …))
                       s*)))
                 seed)</code></pre>

Using <code>imapping-unfold-maybe</code>, however, it's easy to write an
equivalent unfold which computes <em>k</em> and <em>v</em> only once for
each step:

<pre class="example"><code>(imapping-unfold-maybe (lambda (s)
                         (if (stop? s)
                             (nothing)
                             (let-values (((k v) (f s)))
                               (let ((s* …))
                                 (just k v s*)))))
                       seed)</code></pre>

This may be preferable when <em>f</em> is expensive to apply.

<p><code>(alist-&gt;imapping</code>&nbsp;<em>alist</em><code>) → imapping</code></p>

<p>Returns a new imapping containing the associations of <em>alist</em>.
It is an error if the car of any pair in <em>alist</em> is not an
exact integer.</p>

<p>Example:</p>
<pre class="example"><code>(imapping-&gt;alist (alist-&gt;imapping '((1 . b) (0 . a) (2 . c))))
 ⇒ ((0 . a) (1 . b) (2 . c))
</code></pre>

<p><code>(iset-&gt;imapping</code>&nbsp;<em>proc iset</em><code>) → imapping</code></p>

<p><em>proc</em> is of type <code>exact-integer → *</code>.</p>

<p>Returns a new imapping constructed from the elements of the integer
set <em>iset</em> (see
<a href="https://srfi.schemers.org/srfi-217/">SRFI 217</a>).
For each integer <em>k</em> in <em>iset</em>, the association
(<em>k</em>, (<em>proc</em> <em>k</em>)) is added to the imapping.
<em>iset</em> is traversed in an unspecified order.</p>

<p>Example:</p>
<pre class="example"><code>(imapping-&gt;alist (iset-&gt;imapping square (iset 2 4 6 8)))
 ⇒ ((2 . 4) (4 . 16) (6 . 36) (8 . 64))
</code></pre>

<h3 id="predicates">Predicates</h3>

<p><code>(imapping?</code>&nbsp;<em>obj</em><code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if <em>obj</em> is an imapping.</p>

<p><code>(imapping-contains?</code>&nbsp;<em>imap k</em><code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if <em>imap</em> contains an association for key <em>k</em>.</p>
<p>Examples:</p>
<pre class="example"><code>(imapping-contains? (imapping 1 'b) 1) ⇒ #t
(imapping-contains? (imapping 1 'b) 0) ⇒ #f
</code></pre>

<p><code>(imapping-empty?</code>&nbsp;<em>imap</em><code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if <em>imap</em> contains no associations.</p>
<p>Examples:</p>
<pre class="example"><code>(imapping-empty? (alist-&gt;imapping '())) ⇒ #t
(imapping-empty? (alist-&gt;imapping '((0 . a)))) ⇒ #f
</code></pre>

<p><code>(imapping-disjoint?</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂<code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if <em>imap</em>₁ and <em>imap</em>₂ have no keys in common.</p>
<p>Examples:</p>
<pre class="example"><code>(imapping-disjoint? (imapping 0 'a) (imapping 1 'b)) ⇒ #t
(imapping-disjoint? (imapping 1 '(b)) (imapping 1 'b)) ⇒ #f
</code></pre>

<h3 id="accessors">Accessors</h3>

<p><code>(imapping-lookup</code>&nbsp;<em>imap k</em><code>) → maybe[*]</code></p>

<p>If an association <em>(k, v)</em> occurs in <em>imap</em>, returns Just <em>v</em>.
Otherwise, returns Nothing.</p>
<p>Examples:</p>
<pre class="example"><code>(imapping-lookup (imapping 36864 'zap) 36864) ⇒ just[zap]
(imapping-lookup (imapping 0 'a) 36864) ⇒ nothing
</code></pre>

<p><code>(imapping-ref</code>&nbsp;<em>imap k</em><code>) → *</code></p>

<p>If an association <em>(k, v)</em> occurs in <em>imap</em>, returns <em>v</em>.
Otherwise, an error is signaled.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-ref (imapping 36864 'zap) 36864) ⇒ zap
(imapping-ref (imapping 0 'a) 36864) ⇒ ; error
</code></pre>

<p><code>(imapping-ref/default</code>&nbsp;<em>imap k obj</em><code>) → *</code></p>

<p>If an association <em>(k, v)</em> occurs in <em>imap</em>, returns <em>v</em>.
Otherwise, returns <em>obj</em>.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-ref/default (imapping 36864 'zap) 36864 #f) ⇒ zap
(imapping-ref/default (imapping 0 'a) 36864 #f) ⇒ #f
</code></pre>

<p><code>(imapping-min</code>&nbsp;<em>imap</em><code>) → maybe[exact-integer, *]</code></p>

<p>Returns Just <em>k</em> <em>v</em>, where <em>k</em> is the least key of <em>imap</em>.
If <em>imap</em> is empty in the sense of <code>imapping-empty?</code>, returns
Nothing.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-min (imapping 0 'a 1 'b 2 'c)) ⇒ just[0, a]
(imapping-min (imapping)) ⇒ nothing
</code></pre>

<p><code>(imapping-max</code>&nbsp;<em>imap</em><code>) → maybe[exact-integer, *]</code></p>

<p>Returns Just <em>k</em> <em>v</em>, where <em>k</em> is the greatest key of <em>imap</em>.
If <em>imap</em> is empty in the sense of <code>imapping-empty?</code>, returns
Nothing.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-max (imapping 0 'a 1 'b 2 'c)) ⇒ just[2, c]
(imapping-max (imapping)) ⇒ nothing
</code></pre>

<h3 id="updaters">Updaters</h3>

<p><code>(imapping-adjoin</code>&nbsp;<em>imap k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p>Returns a new imapping containing all of the associations of
<em>imap</em> as well as the associations (<em>k</em>₁, <em>v</em>₁), (<em>k</em>₂, <em>k</em>₂), …
The number of key/value arguments must be even.</p>

<p>If any of the keys already have associations in <em>imap</em>, the old
associations are replaced.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-adjoin (imapping 1 'b) 0 'a)) ⇒ ((0 . a) (1 . b))
</code></pre>

<p><code>(imapping-adjoin!</code>&nbsp;<em>imap k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p><code>imapping-adjoin!</code> is the same as <code>imapping-adjoin</code>,
except that it may mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-adjoin/combinator</code>&nbsp;<em>imap proc k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…)</code></p>

<p>Similar to <code>imapping-adjoin</code>, except that duplicate associations
are combined with <em>proc</em>, which is a procedure of type <code>* * → *</code>.
<em>proc</em> is called on the new and old values (in that order) associated
with a duplicated key and is expected to return a value for the key.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-adjoin/combinator (imapping 0 "geordi" 1 "reginald")
                             (lambda (last first)
                               (string-append first " " last))
                             0 "laforge"
                             1 "barclay"))
 ⇒ ((0 . "geordi laforge") (1 . "reginald barclay"))
</code></pre>

<p><code>(imapping-adjoin/combinator!</code>&nbsp;<em>imap proc k</em>₁ <em>obj</em>₁ <em>k</em>₂ <code>…)</code></p>

<p><code>imapping-adjoin/combinator!</code> is the same as
<code>imapping-adjoin/combinator</code>, except that it may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-adjust imap k proc) → imapping</code><br>
<code>(imapping-adjust/key imap k proc) → imapping</code></p>

<p>The <em>proc</em> parameter of <code>imapping-adjust</code> is a
procedure of type <code>* → *</code>; that of
<code>imapping-adjust/key</code> is of type
<code>exact-integer * → *</code>.</p>

<p>Returns a new imapping in which the association (<em>k</em>, <em>v</em>) in <em>imap</em>
is replaced by (<em>k</em>, (<em>proc v</em>)), or by (<em>k</em>, (<em>proc k v</em>)) in the
case of <code>imapping-adjust/key</code>.  If <em>k</em> has no association in <em>imap</em>,
then a copy of <em>imap</em> is returned.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-adjust (imapping 0 -200 1 -100) 0 abs))
 ⇒ '((0 . 200) (1 -100))

(imapping-&gt;alist
 (imapping-adjust/key (imapping 64 "var")
                      64
                      (lambda (k s) (string-append s (number-&gt;string k)))))
 ⇒ ((64 . "var64"))
</code></pre>

<p><code>(imapping-adjust! imap k proc) → imapping</code><br>
<code>(imapping-adjust/key! imap k proc) → imapping</code></p>

<p><code>imapping-adjust!</code> and <code>imapping-adjust/key!</code>
are the same as <code>imapping-adjust</code> and
<code>imapping-adjust/key</code>, respectively, except that they may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-delete imap</code>&nbsp;<em>k</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
those for keys equal to <em>k</em>₁, <em>k</em>₂, ….  If a key does not have an
association in <em>imap</em>, it is ignored.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-delete (imapping 0 -200 1 -100) 0)) ⇒ ((1 . -100))
</code></pre>

<p><code>(imapping-delete! imap</code>&nbsp;<em>k</em>₁ <em>k</em>₂ <code>…) → imapping</code></p>

<p><code>imapping-delete!</code> is the same as
<code>imapping-delete</code>, except that it may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-delete-all</code>&nbsp;<em>imap list</em><code>) → imapping</code></p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
those for keys equal to an element of <em>list</em>.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-delete-all (imapping 0 'a 1 'b 2 'c) '(1 2)))
 ⇒ ((0 . a))
</code></pre>

<p><code>(imapping-delete-all!</code>&nbsp;<em>imap list</em><code>) → imapping</code></p>

<p><code>imapping-delete-all!</code> is the same as
<code>imapping-delete-all</code>, except that it may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-update</code>&nbsp;<em>imap k mproc</em><code>) → imapping</code><br>
<code>(imapping-update/key</code>&nbsp;<em>imap k mproc</em><code>) → imapping</code></p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
that the association for <em>k</em> is updated as follows.  <em>mproc</em> is
applied to the value associated with <em>k</em>.
If it returns Nothing, the association is deleted;
if it returns Just <em>v</em>, then <em>(k, v)</em> is added to the new imapping.</p>

<p><code>imapping-update/key</code> is the same as <code>imapping-update</code>, except that
<em>mproc</em> is called on <em>n</em> and its associated value, in that order.</p>

<p>Simple versions of several other update operations may be defined
in terms of <code>imapping-update</code>, e.g.:</p>

<pre><code>  (imapping-delete imap k)
   ≡
  (imapping-update imap k (lambda (_) (nothing)))

  (imapping-adjoin imap k v)
   ≡
  (imapping-update imap k (lambda (_) (just v)))
</code></pre>
<p>Examples:</p>

<pre class="example"><code>;; Delete the association for 1 if its value is a symbol.
(imapping-&gt;alist
 (imapping-update (imapping 0 'a 1 'b 2 'c)
                  1
                  (lambda (v)
                    (if (symbol? v)
                        (nothing)
                        (just v)))))
 ⇒ ((0 . a) (2 . c))

;; Replace the value associated with 1.
(imapping-&gt;alist
 (imapping-update/key (imapping 0 'a 1 'b 2 'c) 1 (lambda (k _v) (just k))))
 ⇒ ((0 . a) (1 . 1) (2 . c))
</code></pre>

<p><code>(imapping-update!</code>&nbsp;<em>imap k mproc</em><code>) → imapping</code><br>
<code>(imapping-update/key!</code>&nbsp;<em>imap k mproc</em><code>) → imapping</code></p>

<p><code>imapping-update!</code> and <code>imapping-update/key!</code>
are the same as <code>imapping-update</code> and
<code>imapping-update/key</code>, respectively, except that they may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-alter</code>&nbsp;<em>imap k proc</em><code>) → imapping</code></p>

<p><em>proc</em> is a procedure of type <code>maybe[*] → maybe[*]</code>.</p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
that the association, or lack thereof, for <em>k</em> is updated as follows.
If the association <em>(k, v)</em> exists in <em>imap</em>, then <em>proc</em> is called on
Just <em>v</em>; if no such association exists, then <em>proc</em> is called on
Nothing.  If the result of this application is Nothing, the
association is deleted (or no new association is added); if the result
is Just <em>v′</em>, a new association <em>(k, v′)</em> is added to the new
imapping, replacing any old association for <em>k</em>.</p>

<p><code>imapping-alter</code> is a very general operator on imappings, and most
of the other update operations may be defined in terms of it.  For
example:</p>

<pre><code>  (imapping-update imap k f)
   ≡
  (imapping-alter imap k (lambda (m)
                           (maybe-ref m
                                      nothing
                                      (lambda (v) (f v)))))
</code></pre>

<p>Examples:</p>

<pre class="example"><code>;; Insert an association for 4 if it's not present.
(imapping-&gt;alist
 (imapping-alter (imapping 0 'a 1 'b)
                 4
                 (lambda (m)
                   (if (nothing? m) (just 'e) m))))
 ⇒ ((0 . a) (1 . b) (4 . e))

;; Delete an association for 1 if its value is a symbol.
(imapping-&gt;alist
 (imapping-alter (imapping 0 'a 1 'b)
                 1
                 (lambda (m)
                   (maybe-bind m (lambda (v)
                                   (if (symbol? v)
                                       (nothing)
                                       (just v)))))))
 ⇒ ((0 . a))
</code></pre>

<p><code>(imapping-alter!</code>&nbsp;<em>imap k proc</em><code>) → imapping</code></p>

<p><code>imapping-alter!</code> is the same as
<code>imapping-alter</code>, except that it may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-delete-min</code>&nbsp;<em>imap</em><code>) → imapping</code><br>
<code>(imapping-delete-max</code>&nbsp;<em>imap</em><code>) → imapping</code></p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
for the association with the least/greatest key.  If <em>imap</em> is empty,
an error is signalled.</p>

<p><code>(imapping-delete-min!</code>&nbsp;<em>imap</em><code>) → imapping</code><br>
<code>(imapping-delete-max!</code>&nbsp;<em>imap</em><code>) → imapping</code></p>

<p><code>imapping-delete-min!</code> and <code>imapping-delete-max!</code>
are the same as <code>imapping-delete-min</code> and
<code>imapping-delete-max</code>, respectively, except that they may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-delete-min (imapping 0 'a 1 'b 2 'c)) ⇒ ((1 . b) (2 . c))
(imapping-delete-max (imapping 0 'a 1 'b 2 'c)) ⇒ ((0 . a) (1 . b))
</code></pre>

<p><code>(imapping-update-min</code>&nbsp;<em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-max</code>&nbsp;<em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-min/key</code>&nbsp;<em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-max/key</code>&nbsp;<em>imap mproc</em><code>) → imapping</code></p>

<p>The <em>mproc</em> argument of <code>imapping-update-min</code> and <code>-max</code> is of
type <code>* → maybe[*]</code>; that of <code>imapping-update-min/key</code> and of
<code>-max/key</code> is of type <code>exact-integer * → maybe[*]</code>.</p>

<p>Returns a new imapping with the same associations as <em>imap</em>, except
that the association for the least/greatest key <em>k</em> is updated as
follows.  <em>mproc</em> is applied to the value associated with <em>k</em> and is
expected to return a Maybe value.  If it returns Nothing, the
association is deleted; if it returns Just <em>v</em>, then <em>(k, v)</em> is added
to the new imapping.  If <em>imap</em> is empty, an error is signalled.</p>

<p><code>imapping-update-min/key</code> and <code>imapping-update-max/key</code> are the same
as <code>imapping-update-min</code> and <code>imapping-update-max</code>, respectively,
except that <em>mproc</em> is called on <em>k</em> and its associated value, in that
order.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-update-min (imapping -5 "phaser" -1 "tricorder")
                      (lambda (v)
                        (if (symbol? v)
                            (just v)
                            (nothing)))))
 ⇒ ((-1 . "tricorder"))

(imapping-&gt;alist
 (imapping-update-max/key (imapping -5 "phaser" -1 "tricorder")
                          (lambda (k v)
                            (if (and (negative? k) (string? v))
                                (just (string-length v))
                                (nothing)))))
 ⇒ ((-5 . "phaser") (-1 . 9))
</code></pre>

<p><code>(imapping-update-min!</code>&nbsp;<em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-max!</code>&nbsp;<em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-min/key!</code>&nbsp;<em>imap mproc</em><code>) → imapping</code><br>
<code>(imapping-update-max/key!</code>&nbsp;<em>imap mproc</em><code>) → imapping</code></p>

<p>These are linear-update variants of
<code>imapping-update-min</code>, etc..  They may
mutate and return the <em>imap</em> argument instead of allocating
a new imapping.</p>

<p><code>(imapping-pop-min</code>&nbsp;<em>imap</em><code>) → maybe[exact-integer, *, imapping]</code><br>
<code>(imapping-pop-max</code>&nbsp;<em>imap</em><code>) → maybe[exact-integer, *, imapping]</code></p>

<p>Returns Just <em>k v imap′</em>, where (<em>k</em>, <em>v</em>) is the association of
<em>imap</em> with the least/greatest key and <em>imap′</em> is a newly-allocated
imapping containing all of the associations of <em>imap</em> except for
(<em>k</em>, <em>v</em>).  If <em>imap</em> is empty, returns Nothing.</p>

<p>Example:</p>

<pre class="example"><code>(maybe-let*-values (((k v imap)
                     (imapping-pop-min (imapping 0 'a 1 'b 2 'c))))
  (values k v (imapping-&gt;alist imap)))
 ⇒ (just 0 a ((1 . b) (2 . c)))
</code></pre>

<p><code>(imapping-pop-min!</code>&nbsp;<em>imap</em><code>) → maybe[exact-integer, *, imapping]</code><br>
<code>(imapping-pop-max!</code>&nbsp;<em>imap</em><code>) → maybe[exact-integer, *, imapping]</code></p>

<p><code>imapping-pop-min!</code> and <code>imapping-pop-max!</code>
are the same as <code>imapping-pop-min</code> and
<code>imapping-pop-max</code>, respectively, except that they may
mutate and return the <em>imap</em> argument instead
of allocating a new imapping.</p>

<h3 id="whole">The whole imapping</h3>

<p><code>(imapping-size</code>&nbsp;<em>imap</em><code>) → exact-integer</code></p>

<p>Returns the number of associations in <em>imap</em>.</p>

<p><code>(imapping-count</code>&nbsp;<em>pred imap</em><code>) → exact-integer</code><br>
<code>(imapping-count/key</code>&nbsp;<em>pred imap</em><code>) → exact-integer</code></p>

<p>Returns the number of associations in <em>imap</em> whose values satisfy
<em>pred</em>.</p>

<p><code>imapping-count/key</code> is the same, except that <em>pred</em> is called on
the key and value of each association.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-count even? (imapping 0 1 1 2 2 4 3 8)) ⇒ 3
(imapping-count/key (lambda (k s) (= k (string-length s)))
                    (imapping 0 "x" 1 "y" 2 "z"))
 ⇒ 1
</code></pre>

<p><code>(imapping-any?</code>&nbsp;<em>pred imap</em><code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if there exists an association in <em>imap</em> whose value
satisfies <em>pred</em>.  <em>imap</em> is traversed in ascending numerical order
of keys.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-any? odd? (imapping 0 1 1 2 2 4 3 8)) ⇒ #t
</code></pre>

<p><code>(imapping-every?</code>&nbsp;<em>pred imap</em><code>) → boolean</code></p>

<p>Returns <code>#t</code> if and only if the value of every association in <em>imap</em> satisfies
<em>pred</em>, or if <em>imap</em> is empty.  <em>imap</em> is traversed in ascending
numerical order of keys.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-every? integer? (imapping 0 1 1 2 2 4 3 8)) ⇒ #t
</code></pre>

<h3 id="traversal">Traversal</h3>

<p><code>(imapping-map</code>&nbsp;<em>proc imap</em><code>) → imapping</code><br>
<code>(imapping-map/key</code>&nbsp;<em>proc imap</em><code>) → imapping</code></p>

<p>The <em>proc</em> argument of <code>imapping-map</code> is of type <code>* → *</code>;
that of <code>imapping-map/key</code> is of type <code>exact-integer * → *</code>.</p>

<p>Returns a new imapping.  For each association <em>(n, v)</em> in <em>imap</em>,
the association <em>(n, (proc v))</em> is added to the new imapping.
Associations are traversed in an arbitrary order.  The dynamic order
of the applications of <em>proc</em> to the elements of <em>imap</em> is
unspecified.</p>

<p><code>imapping-map/key</code> is the same, except that <em>proc</em> is called on
the key and value of each association.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-map string-length
               (imapping 0 "picard" 1 "riker" 2 "troi")))
 ⇒ ((0 . 6) (2 . 5) (3 . 4))

(imapping-&gt;alist
 (imapping-map/key (lambda (k s)
                     (string-append s (number-&gt;string k)))
                   (imapping 256 "x" 512 "y" 1024 "z")))
 ⇒ ((256 . "x256") (512 . "y512") (1024 . "z1024"))
</code></pre>

<p>Note that, in contrast to SRFI 146&rsquo;s map procedures, these procedures
transform the values of <em>imap</em> only; that is, the set of keys of the
resulting imapping is the same as that of <em>imap</em>.</p>

<p><code>(imapping-map!</code>&nbsp;<em>proc imap</em><code>) → imapping</code><br>
<code>(imapping-map/key!</code>&nbsp;<em>proc imap</em><code>) → imapping</code></p>

<p><code>imapping-map!</code> and <code>imapping-map/key!</code>
are the same as <code>imapping-map</code> and
<code>imapping-map/key</code>, respectively, except that they may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-for-each</code>&nbsp;<em>proc imap</em><code>) → unspecified</code><br>
<code>(imapping-for-each/key</code>&nbsp;<em>proc imap</em><code>) → unspecified</code></p>

<p>Calls <em>proc</em> on the value of each association in <em>imap</em> and returns
an unspecified value.  <em>imap</em> is traversed in ascending numerical
order of keys.</p>

<p><code>imapping-for-each/key</code> is the same, except that <em>proc</em> is called on
the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(let ((sum 0))
  (imapping-for-each (lambda (v) (set! sum (+ sum v)))
                     (imapping 0 1 1 2 2 4 3 8))
  sum)
 ⇒ 15
</code></pre>

<p><code>(imapping-fold</code>&nbsp;<em>kons knil imap</em><code>) → *</code><br>
<code>(imapping-fold-right</code>&nbsp;<em>kons knil imap</em><code>) → *</code><br>
<code>(imapping-fold/key</code>&nbsp;<em>kons knil imap</em><code>) → *</code><br>
<code>(imapping-fold-right/key</code>&nbsp;<em>kons knil imap</em><code>) → *</code></p>

<p>The <em>kons</em> argument of <code>imapping-fold</code> and <code>imapping-fold-right</code> is a
procedure of type <code>* * → *</code>; that of <code>imapping-fold/key</code>
and of <code>imapping-fold-right/key</code> is of type <code>exact-integer * * → *</code>.
<em>knil</em> can be any object.</p>

<p>Folds <em>kons</em> over <em>imap</em>, using <em>knil</em> as the base value.  At
each step, <em>kons</em> is applied to the value of an association and to
the result of the last application.
<code>imapping-fold</code> folds in ascending numerical order of keys;
<code>imapping-fold-right</code> folds in descending order.</p>

<p><code>imapping-fold/key</code> and <code>imapping-fold-right/key</code> are the same
as <code>imapping-fold</code> and <code>imapping-fold-right</code>, respectively,
except that <em>kons</em> is also passed the key of each association as its first
argument.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-fold-right cons '() (imapping 0 "worf" 1 "data" 2 "crusher"))
 ⇒ ("worf" "data" "crusher")

(imapping-fold/key (lambda (k _ ks) (cons k ks))
                   '()
                   (imapping 0 "worf" 1 "data" 2 "crusher"))
 ⇒ (2 1 0)
</code></pre>

<p><code>(imapping-map-&gt;list</code>&nbsp;<em>proc imap</em><code>) → list</code><br>
<code>(imapping-map/key-&gt;list</code>&nbsp;<em>proc imap</em><code>) → list</code></p>

<p>Efficient fusion of <code>(imapping-values (imapping-map</code>&nbsp;<em>proc imap</em><code>))</code>.</p>

<p><code>imapping-map/key-&gt;list</code> is the same, except that <em>proc</em> is called on
the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-map-&gt;list string-length
                     (imapping 0 "picard" 1 "riker" 2 "troi")))
 ⇒ (6 5 4)
</code></pre>

<p><code>(imapping-filter-map</code>&nbsp;<em>proc imap</em><code>) → imapping</code><br>
<code>(imapping-filter-map/key</code>&nbsp;<em>proc imap</em><code>) → imapping</code></p>

<p>The <em>proc</em> parameter of <code>imapping-filter-map</code> is a
procedure of type <code>* → *-or-#f</code>; that of
<code>imapping-filter-map/key</code> is of type
<code>exact-integer * → *-or-#f</code>.</p>

<p><code>imapping-filter-map</code> is similar to <code>imapping-map</code>,
but only associations for which <em>proc</em> returns a true value are
added to the new imapping.</p>

<p><code>imapping-filter-map/key</code> is the same, except that <em>proc</em>
is called on the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-filter-map (lambda (v)
                        (and (positive? v) (square v)))
                      (imapping 0 2 1 -4 2 8)))
 ⇒ ((0 . 4) (2 . 64))
</code></pre>

<p><code>(imapping-filter-map!</code>&nbsp;<em>proc imap</em><code>) → imapping</code><br>
<code>(imapping-filter-map/key!</code>&nbsp;<em>proc imap</em><code>) → imapping</code></p>

<p><code>imapping-filter-map!</code> and <code>imapping-filter-map/key!</code>
are the same as <code>imapping-filter-map</code> and
<code>imapping-filter-map/key</code>, respectively, except that they may
mutate and return the <em>imap</em> argument instead of
allocating a new imapping.</p>

<p><code>(imapping-map-either</code>&nbsp;<em>proc imap</em><code>) → [imapping, imapping]</code><br>
<code>(imapping-map-either/key</code>&nbsp;<em>proc imap</em><code>) → [imapping, imapping]</code></p>

<p>The <em>proc</em> of <code>imapping-map-either</code> is a procedure
of type <code>* → either[*]</code>, where <code>either[*]</code> denotes
a SRFI 189 Either containing a single value.  The <em>proc</em> parameter
of <code>imapping-map-either/key</code> is of type
<code>exact-integer * → either[*]</code>.</p>

<p><code>imapping-map-either</code> maps <em>proc</em> over the values
of <em>imap</em> and returns imappings of the Left and of the Right
results.  For each association (<em>k</em>, <em>v</em>) in
<em>imap</em>, (<em>proc v</em>) is evaluated.  If the result is a
Left of a value <em>v</em>₁, then the association (<em>k</em>,
<em>v</em>₁) is added to the first new imapping.  If it is instead a
Right of <em>v</em>₂, then the association (<em>k</em>, <em>v</em>₂)
is added to the second new imapping.</p>

<p><code>imapping-map-either/key</code> is the same, except that <em>proc</em>
is called on the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(let-values (((lefts rights)
              (imapping-map-either
               (lambda (v)
                 (if (&gt;= v 0)
                     (right v)
                     (left v)))
               (imapping 0 -50 4 -25 8 25 12 50))))
  (values (imapping-&gt;alist lefts)
          (imapping-&gt;alist rights)))
 ⇒ ((0 . -50) (4 . -25))
   ((8 . 25) (12 . 50))
</code></pre>

<p><code>(imapping-map-either!</code>&nbsp;<em>proc imap</em><code>) → imapping imapping</code><br>
<code>(imapping-map-either/key!</code>&nbsp;<em>proc imap</em><code>) → imapping imapping</code></p>

<p><code>imapping-map-either!</code> and <code>imapping-map-either/key!</code>
are the same as <code>imapping-map-either</code> and
<code>imapping-map-either/key</code>, respectively, except that they may
mutate the <em>imap</em> parameter to produce their results.</p>

<p><code>(imapping-relation-map</code>&nbsp;<em>proc imap</em><code>) → imapping</code></p>

<p><code>proc</code> must be a procedure of type
<code>exact-integer * → [exact-integer, *]</code>.</p>

<p>Returns a new imapping whose associations are the results of
transforming both the keys and the values of <em>imap</em> with
<em>proc</em>.  For each association (<em>k</em>,
<em>v</em>) in <em>imap</em>, (<em>proc k v</em>) is evaluated to
return a new key and a new value which are associated in the new
imapping.  Duplicate keys are replaced, but the results in this case
are unpredictable; if <em>proc</em> is not injective, that is, if it
produces multiple associations with the same key, then it is unspecified
which one of these associations will be present in the resulting
imapping. The dynamic order of the applications of <em>proc</em> to the
elements of <em>imap</em> is unspecified.</p>

<p><strong>Rationale:</strong> <code>imapping-relation-map</code>
corresponds to <code>mapping-map</code> from SRFI 146 and is specified
primarily for compatibility with that SRFI.  It generalizes
<code>imapping-map</code> and <code>imapping-map/key</code>, and can
be used to produce a wide range of transformations on imappings.  This
generality comes at a price, however.  Certain familiar laws that hold
of <code>imapping-map</code> and other Scheme "map" functions do not
hold of <code>imapping-relation-map</code>; in particular, the size of
the input imapping <em>imap</em> may not be preserved, and a key with an
association in <em>imap</em> may not have an association in the
transformed imapping.</p>

<p>As such, <code>imapping-map</code> and <code>imapping-map/key</code>
likely conform better to the familiar pattern of Scheme "map" functions,
while being sufficiently general for most purposes.</p>

<h3 id="filter">Filter</h3>

<p><code>(imapping-filter</code>&nbsp;<em>pred imap</em><code>) → imapping</code><br>
<code>(imapping-filter/key</code>&nbsp;<em>pred imap</em><code>) → imapping</code></p>

<p>Returns a new imapping containing all of the associations of <em>imap</em>
whose values satisfy <em>pred</em>.</p>

<p><code>imapping-filter/key</code> is the same, except that <em>pred</em> is applied to
the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-filter positive?
                                  (imapping 0 2 1 -4 2 8 3 -16)))
 ⇒ ((0 . 2) (2 . 8))
</code></pre>

<p><code>(imapping-filter!</code>&nbsp;<em>pred imap</em><code>) → imapping</code><br>
<code>(imapping-filter/key!</code>&nbsp;<em>pred imap</em><code>) → imapping</code></p>

<p><code>imapping-filter!</code> and <code>imapping-filter/key!</code>
are the same as <code>imapping-filter</code> and
<code>imapping-filter/key</code>, respectively, except that they may
mutate and return the <em>imap</em> parameter instead of
allocating a new imapping.</p>

<p><code>(imapping-remove</code>&nbsp;<em>pred imap</em><code>) → imapping</code><br>
<code>(imapping-remove/key</code>&nbsp;<em>pred imap</em><code>) → imapping</code></p>

<p>Returns a new imapping containing all of the associations of <em>imap</em>
whose values do not satisfy <em>pred</em>.</p>

<p><code>imapping-remove/key</code> is the same, except that <em>pred</em> is applied to
the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-remove positive?
                                  (imapping 0 2 1 -4 2 8 3 -16)))
 ⇒ ((1 . -4) (3 . -16))
</code></pre>

<p><code>(imapping-remove!</code>&nbsp;<em>pred imap</em><code>) → imapping</code><br>
<code>(imapping-remove/key!</code>&nbsp;<em>pred imap</em><code>) → imapping</code></p>

<p><code>imapping-remove!</code> and <code>imapping-remove/key!</code>
are the same as <code>imapping-remove</code> and
<code>imapping-remove/key</code>, respectively, except that they may
mutate and return the <em>imap</em> parameter instead of
allocating a new imapping.</p>

<p><code>(imapping-partition</code>&nbsp;<em>pred imap</em><code>) → [imapping, imapping]</code><br>
<code>(imapping-partition/key</code>&nbsp;<em>pred imap</em><code>) → [imapping, imapping]</code></p>

<p>Returns two new imappings: the first contains all associations of
<em>imap</em> whose values satisfy <em>pred</em>, and the second contains those
whose values do not.</p>

<p><code>imapping-partition/key</code> is the same, except that <em>pred</em> is applied to
the key and value of each association.</p>

<p>Example:</p>

<pre class="example"><code>(let-values (((pos ~pos) (imapping-partition positive?
                                             (imapping 0 2 1 -4 2 8 3 -16))))
  (values (imapping-&gt;alist pos)
          (imapping-&gt;alist ~pos)))
 ⇒ ((0 . 2) (2 . 8))
   ((1 . -4) (3 . -16))
</code></pre>

<p><code>(imapping-partition!</code>&nbsp;<em>pred imap</em><code>) → imapping</code><br>
<code>(imapping-partition/key!</code>&nbsp;<em>pred imap</em><code>) → imapping</code></p>

<p><code>imapping-partition!</code> and <code>imapping-partition/key!</code>
are the same as <code>imapping-partition</code> and
<code>imapping-partition/key</code>, respectively, except that they may
mutate the <em>imap</em> parameter to produce their results.</p>

<h3 id="conversion">Conversion</h3>

<p><code>(imapping-copy</code>&nbsp;<em>imap</em><code>) → imapping</code></p>

<p>Returns a newly allocated imapping containing the associations of
<code>imap</code>.</p>

<p><code>(imapping-&gt;alist</code>&nbsp;<em>imap</em><code>) → alist[exact-integer, *]</code></p>

<p>Returns a car/cdr alist containing the associations of <em>imap</em> in
ascending numerical order of keys.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping 1 'a 2 'b)) ⇒ ((1 . a) (2 . b))
</code></pre>

<p><code>(imapping-&gt;decreasing-alist</code>&nbsp;<em>imap</em><code>) → alist[exact-integer, *]</code></p>

<p>Returns a car/cdr alist containing the associations of <em>imap</em> in
decreasing numerical order of keys.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping 1 'a 2 'b)) ⇒ ((2 . b) (1 . a))
</code></pre>

<p><code>(imapping-keys</code>&nbsp;<em>imap</em><code>) → list[exact-integer]</code></p>

<p>Returns the keys of <em>imap</em> as a list in ascending numerical order.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-keys (imapping 137 'a -24 'b -5072 'c)) ⇒ (-5072 -24 137)
</code></pre>

<p><code>(imapping-keys-set</code>&nbsp;<em>imap</em><code>) → iset</code></p>

<p>Returns a SRFI 217 integer set containing the keys of <em>imap</em>.</p>

<p>Example:</p>

<pre class="example"><code>(iset-&gt;list (imapping-keys-set (imapping 137 'a -24 'b -5072 'c)))
 ⇒ (-5072 -24 137)
</code></pre>

<p><code>(imapping-values</code>&nbsp;<em>imap</em><code>) → list[*]</code></p>

<p>Returns the elements of <em>imap</em> as a list in ascending numerical
order of key.</p>

<p>Example:</p>

<pre class="example"><code>(imapping-values (imapping 0 "picard" 1 "riker" 2 "troi"))
 ⇒ ("picard" "riker" "troi")
</code></pre>

<h3 id="comparison">Comparison</h3>

<p><code>(imapping=?</code>&nbsp;<em>comp imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code></p>

<p>Returns <code>#t</code> if and only if all of the <em>imaps</em> contain equal
associations.  Two associations are equal exactly when their keys are
equal (in the sense of <code>=</code>) and if their values are equal in the sense
of the equality predicate of <em>comp</em> (see
<a href="https://srfi.schemers.org/srfi-128/">SRFI 128</a>).</p>

<p>Examples:</p>

<pre class="example"><code>(imapping=? (make-default-comparator)
            (imapping 1 'a 2 'b)
            (imapping 2 'b 1 'a))
 ⇒ #t

(imapping=? (make-default-comparator)
            (imapping 1 'a 2 'b 3 'c)
            (imapping 2 'b 1 'a))
 ⇒ #f
</code></pre>

<p><code>(imapping&lt;?</code>&nbsp;<em>comp</em> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code><br>
<code>(imapping&lt;=?</code>&nbsp;<em>comp</em> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code><br>
<code>(imapping&gt;?</code>&nbsp;<em>comp</em> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code><br>
<code>(imapping&gt;=?</code>&nbsp;<em>comp</em> <em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ <code>…) → boolean</code></p>

<p>Returns <code>#t</code> if and only if each <em>imap</em> other than the last is a proper
subset/subset/proper superset/superset of the following <em>imap</em>.  Values are
compared using the equality predicate of <em>comp</em>.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping&lt;? (make-default-comparator)
            (imapping 1 'a 2 'b)
            (imapping 2 'b 1 'a 3 'c))
 ⇒ #t

(imapping&gt;? (make-default-comparator)
            (imapping 2 'b 1 "worf" 3 'c)
            (imapping 1 'a 2 'b))
 ⇒ #f

(imapping&gt;=? (make-default-comparator)
             (imapping 2 'b 1 'a 3 'c)
             (imapping 1 'a 2 'b)
             (imapping 2 'b 1 'a)
             (imapping 1 'a))
 ⇒ #t
</code></pre>

<h3 id="settheory">Set theory operations</h3>

<p><code>(imapping-union</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-intersection</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-difference</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-xor</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂<code>) → imapping</code></p>

<p>Return a newly allocated imapping whose set of associations is the
union, intersection, asymmetric difference, or symmetric difference of
the sets of associations of the <em>imaps</em>.  Asymmetric difference is
extended to more than two imappings by taking the difference between
the first imapping and the union of the others.  Symmetric difference
is not extended beyond two imappings.  When comparing associations,
only the keys are compared.  In case of duplicate keys, associations
in the result imapping are drawn from the first imapping in which they
appear.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist (imapping-union (imapping 0 'a 2 'c)
                                 (imapping 1 'b 3 'd)))
 ⇒ ((0 . a) (1 . b) (2 . c) (3 . d))

(imapping-&gt;alist
 (imapping-intersection (imapping 0 'a 2 'c)
                        (imapping 1 'b 2 'c 3 'd)
                        (imapping 2 'c 4 'e)))
 ⇒ ((2 . c))

(imapping-&gt;alist (imapping-difference (imapping 0 'a 1 'b 2 'c)
                                      (imapping 2 "worf")
                                      (imapping 1 "data")))
 ⇒ ((0 . a))
</code></pre>

<p><code>(imapping-union!</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-intersection!</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-difference!</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-xor!</code>&nbsp;<em>imap</em>₁ <em>imap</em>₂<code>) → imapping</code></p>

<p>These are linear-update variants of
<code>imapping-union</code>, etc..  They may
mutate <strong>any</strong> of the <em>imap</em> parameters to
produce their results.</p>

<p><code>(imapping-union/combinator</code>&nbsp;<em>proc imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-intersection/combinator</code>&nbsp;<em>proc imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code></p>

<p><em>proc</em> is a procedure of type <code>* * → *</code>.</p>

<p>Return a new imapping whose set of keys is the union/intersection of
the sets of keys of the <em>imaps</em>.  The values associated with duplicate
keys are combined left-associatively with <em>proc</em>; that is, if an integer <em>k</em> is associated
with values <em>v</em>₁, <em>v</em>₂, …, <em>v</em>ₙ in <em>imap</em>₁, <em>imap</em>₂, …, <em>imap</em>ₙ,
respectively, then the resulting imapping will contain the association
(<em>k</em>, (<em>proc</em> … (<em>proc v</em>₁ <em>v</em>₂) … <em>v</em>ₙ)).</p>

<p>Examples:</p>

<pre class="example"><code>;; Right-biased union.
(imapping-&gt;alist
 (imapping-union/combinator (lambda (_l r) r)
                            (imapping 1 'b 2 'c)
                            (imapping 2 "data" 3 "picard")))

 ⇒ ((1 . b) (2 . "data") (3 . "picard"))

(imapping-&gt;alist
 (imapping-intersection/combinator
  (lambda (l r) (string-append l " " r))
  (imapping 1 "q" 3 "jean-luc" 5 "miles" 7 "quark")
  (imapping 3 "picard" 5 "o'brien")))

 ⇒ ((3 . "jean-luc picard") (5 . "miles o'brien"))
</code></pre>

<p><code>(imapping-union/combinator!</code>&nbsp;<em>proc imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code><br>
<code>(imapping-intersection/combinator!</code>&nbsp;<em>proc imap</em>₁ <em>imap</em>₂ <em>imap</em>₃ …<code>) → imapping</code></p>

<p>These are linear-update variants of <code>imapping-union/combinator</code>
and <code>imapping-intersection/combinator</code>.  They may
mutate <strong>any</strong> of the <em>imap</em> parameters to
produce their results.</p>

<h3 id="submappings">Submappings</h3>

<p><code>(imapping-open-interval</code>&nbsp;<em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-closed-interval</code>&nbsp;<em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-open-closed-interval</code>&nbsp;<em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-closed-open-interval</code>&nbsp;<em>imap low high</em><code>) → imapping</code></p>

<p><em>low</em> and <em>high</em> are both exact integers.</p>

<p>Procedures that return a subset of <em>imap</em> containing the associations
whose keys are contained in the interval from <em>low</em> to <em>high</em>.  The
interval is open/closed/open below and closed above/open
above and closed below.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist
 (imapping-open-interval (imapping 0 'a 1 'b 2 'c 3 'd) 1 3))
 ⇒ ((2 . c))

(imapping-&gt;alist
 (imapping-closed-interval (imapping 0 'a 1 'b 2 'c 3 'd) 1 3))
 ⇒ ((1 . b) (2 . c) (3 . d))

(imapping-&gt;alist
 (imapping-closed-open-interval (imapping 0 'a 1 'b 2 'c 3 'd) 1 3))
 ⇒ ((1 . b) (2 . c))
</code></pre>

<p><code>(imapping-open-interval!</code>&nbsp;<em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-closed-interval!</code>&nbsp;<em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-open-closed-interval!</code>&nbsp;<em>imap low high</em><code>) → imapping</code><br>
<code>(imapping-closed-open-interval!</code>&nbsp;<em>imap low high</em><code>) → imapping</code></p>

<p>These are linear-update variants of
<code>imapping-open-interval</code>, etc..  They may
mutate and return the <em>imap</em> parameter instead of allocating
a new imapping.</p>

<p><code>(isubmapping=</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&lt;</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&lt;=</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&gt;</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&gt;=</code>&nbsp;<em>imap k</em><code>) → imapping</code></p>

<p>Procedures that return an imapping containing the associations of
<em>imap</em> whose keys are equal to/less than/less than or equal
to/greater than/greater than or equal to <em>k</em>.  Note that the result of
<code>isubmapping=</code> contains at most one element.</p>

<p>Examples:</p>

<pre class="example"><code>(imapping-&gt;alist
 (isubmapping= (imapping 0 'a 1 'b 2 'c 3 'd) 2))
 ⇒ ((2 . c))

(imapping-&gt;alist
 (isubmapping&lt; (imapping 0 'a 1 'b 2 'c 3 'd) 2))
 ⇒ ((0 . a) (1 . b))

(imapping-&gt;alist
 (isubmapping&gt;= (imapping 0 'a 1 'b 2 'c 3 'd) 2))
 ⇒ ((2 . c) (3 . d))
</code></pre>

<p><code>(isubmapping=!</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&lt;!</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&lt;=!</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&gt;!</code>&nbsp;<em>imap k</em><code>) → imapping</code><br>
<code>(isubmapping&gt;=!</code>&nbsp;<em>imap k</em><code>) → imapping</code></p>

<p>These are linear-update variants of
<code>isubmapping=</code>, etc..  They may
mutate and return the <em>imap</em> parameter instead of allocating
a new imapping.</p>

<h2 id="implementation">Implementation</h2>

<p>The sample implementation is found in the repository for this SRFI.
The imapping implementation is based on the radix (Patricia) tree
approach described by Chris Okasaki and Andrew Gill in &ldquo;Fast
Mergeable Integer Maps&rdquo; (see <a href="#references">References</a>).
These trees provide fast insert, lookup, and set-theoretical operations.</p>

<p>The implementation should be portable without changes to any R7RS
Scheme that provides SRFIs 1, 128, 143, 145, and 217.  The provided
tests can be run with SRFIs 64 or 78; additional shims for the test
libraries preferred by <a href="http://synthcode.com/scheme/chibi/lib/chibi/test.html">chibi-scheme</a>
and <a href="https://wiki.call-cc.org/eggref/5/test">CHICKEN</a> are also
included.</p>

<h2>Acknowledgements</h2>

<p>Thanks to Marc-Nieper Wißkirchen and Arthur A. Gleckler, the
authors of SRFI 146, as well as to Daan Leijen and Andriy Palamarchuk,
who created the Haskell IntMap library.  These libraries provided
critical inspiration and implementation clues in the creation of this
SRFI.</p>

<p>Thanks to the SRFI editor and to the contributors to the SRFI
mailing list.</p>

<p>This SRFI contains ideas and language drawn from dozens of other
SRFIs, in particular specifications by Olin Shivers, John Cowan, and
Taylor Campbell.  The R7RS and earlier standards also provided
constant design and literary guidance.  Thus, little of what appears
in this SRFI is &ldquo;original&rdquo;.  Thanks to all of the Schemers who have
contributed their knowledge and time to the SRFI process and to the
R<sup><em>n</em></sup>RS standards.</p>

<p>Of course, none of this should be understood to imply that any of
the individuals mentioned above endorse this SRFI.</p>

<h2 id="references">References</h2>

<p>Alex Shinn, John Cowan, &amp; Arthur A. Gleckler, eds., &ldquo;Revised<sup>7</sup> Report
on the Algorithmic Language Scheme&rdquo; (R7RS) (2013).  Available
<a href="https://small.r7rs.org/">on the Web</a>.</p>

<p>Chris Okasaki &amp; Andrew Gill, &ldquo;Fast Mergeable Integer Maps&rdquo;,
1998 <em>Workshop on ML</em>, p. 77-86.</p>

<p>S. Bradner, &ldquo;Key words for use in RFCs to Indicate Requirement Levels&rdquo;.
1997. http://www.ietf.org/rfc/rfc2119.txt</p>

<h2>Copyright</h2>

<p>&copy; 2020 Wolfgang Corcoran-Mathe.  All rights reserved.</p>

<p>Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
&ldquo;Software&rdquo;), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:</p>

<p>The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial portions
of the Software.</p>

<p>THE SOFTWARE IS PROVIDED &ldquo;AS IS&rdquo;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>
<hr>
<address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address>
</body>
</html>
